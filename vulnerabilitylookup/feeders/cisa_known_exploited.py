from __future__ import annotations

import logging
import requests

from datetime import datetime
from pathlib import Path
from typing import Callable
from uuid import uuid4

import orjson

from ..helpers import fromisoformat_wrapper

from .abstract_feeder import AbstractFeeder


class CISAKnownExploited(AbstractFeeder):
    def __init__(self) -> None:
        super().__init__(Path(__file__).stem)
        self.url = 'https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json'

    def _load_logging_config(self) -> None:
        cur_path = Path(__file__)
        if not (cur_path.parent / f'{cur_path.stem}_logging.json').exists():
            return
        with (cur_path.parent / f'{cur_path.stem}_logging.json').open() as f:
            log_config = orjson.loads(f.read())
        logging.config.dictConfig(log_config)

    def update(self, stop: Callable[..., bool]) -> bool:
        # NOTE: Not checking stop in this method as the main thing that will lock is the request
        # And this one has a timeout set to 300 seconds
        last_update: datetime | None
        if _last_update_str := self.storage.hget('last_updates', self.name):
            last_update = fromisoformat_wrapper(_last_update_str.decode())
        else:
            last_update = None

        r = requests.get(self.url, timeout=300)
        try:
            r.raise_for_status()
        except Exception as e:
            self.logger.debug(f'Failed to fetch: {e}')
            return False

        known_exploited_vulnerabilities = r.json()
        current_update = fromisoformat_wrapper(known_exploited_vulnerabilities['dateReleased'])
        if last_update and current_update <= last_update:
            self.logger.debug(f'cisa_known_exploited: already loaded ({current_update})')
            return False

        index_cisa: dict[str, float] = {}
        for exploited_vuln in known_exploited_vulnerabilities['vulnerabilities']:
            cve_id = exploited_vuln['cveID'].lower()
            # do we already have a meta entry for this source?
            if _meta_uuid := self.storage.hget(f'{cve_id}:meta', self.name):
                meta_uuid = _meta_uuid.decode()
            else:
                meta_uuid = str(uuid4())
                self.storage.hset(f'{cve_id}:meta', mapping={self.name: meta_uuid})
            # No proper identifier for this source, so we use an UUID
            self.storage.hset(f'{self.name}:{meta_uuid}', mapping={k: v for k, v in exploited_vuln.items() if v})
            index_cisa[meta_uuid] = fromisoformat_wrapper(exploited_vuln['dateAdded']).timestamp()

        # We do not store that in the index key as they are meta
        self.storage.zadd(f'index:{self.name}', index_cisa)  # type: ignore

        self.storage.hset('last_updates', mapping={self.name: current_update.isoformat()})
        self.logger.info('Import done.')
        return True
