from __future__ import annotations

import json
import logging
import requests

from datetime import datetime
from pathlib import Path
from typing import Callable
from uuid import uuid4

import orjson

from ..helpers import fromisoformat_wrapper

from .abstract_feeder import AbstractFeeder


class CISAKnownExploited(AbstractFeeder):
    def __init__(self) -> None:
        super().__init__(Path(__file__).stem)
        self.url = 'https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json'

    def _load_logging_config(self) -> None:
        cur_path = Path(__file__)
        if not (cur_path.parent / f'{cur_path.stem}_logging.json').exists():
            return
        with (cur_path.parent / f'{cur_path.stem}_logging.json').open() as f:
            log_config = orjson.loads(f.read())
        logging.config.dictConfig(log_config)

    def update(self, stop: Callable[..., bool]) -> bool:
        # NOTE: Not checking stop in this method as the main thing that will lock is the request
        # And this one has a timeout set to 300 seconds
        last_update: datetime | None
        if _last_update_str := self.storage.hget('last_updates', self.name):
            last_update = fromisoformat_wrapper(_last_update_str.decode())
        else:
            last_update = None

        r = requests.get(self.url, timeout=300)
        try:
            r.raise_for_status()
        except Exception as e:
            self.logger.debug(f'Failed to fetch: {e}')
            return False

        known_exploited_vulnerabilities = r.json()
        current_update = fromisoformat_wrapper(known_exploited_vulnerabilities['dateReleased'])
        if last_update and current_update <= last_update:
            self.logger.debug(f'cisa_known_exploited: already loaded ({current_update})')
            return False

        index_cisa: dict[str, float] = {}
        for exploited_vuln in known_exploited_vulnerabilities['vulnerabilities']:
            cve_id = exploited_vuln['cveID'].lower()
            # do we already have a meta entry for this source?
            if _meta_uuid := self.storage.hget(f'{cve_id}:meta', self.name):
                meta_uuid = _meta_uuid.decode()
            else:
                meta_uuid = str(uuid4())
                self.storage.hset(f'{cve_id}:meta', mapping={self.name: meta_uuid})
            # No proper identifier for this source, so we use an UUID
            prepared_entry = {}
            for k, v in exploited_vuln.items():
                if not v:
                    continue
                if isinstance(v, list):
                    prepared_entry[k] = json.dumps(v)
                else:
                    prepared_entry[k] = v
            self.storage.hset(f'{self.name}:{meta_uuid}', mapping=prepared_entry)
            index_cisa[meta_uuid] = fromisoformat_wrapper(exploited_vuln['dateAdded']).timestamp()

        # We do not store that in the index key as they are meta
        self.storage.zadd(f'index:{self.name}', index_cisa)  # type: ignore

        self.storage.hset('last_updates', mapping={self.name: current_update.isoformat()})
        self.logger.info('Import done.')
        return True
