from __future__ import annotations

import requests

from datetime import datetime, timedelta
from pathlib import Path
import orjson
from uuid import uuid4
from ..helpers import fromisoformat_wrapper

from .abstract_feeder import AbstractFeeder


class NVD(AbstractFeeder):
    def __init__(self) -> None:
        super().__init__(Path(__file__).stem)
        if 'apikey' in self.config:
            self.url_apikey_param = {"apiKey": self.config['apikey']}
        else:
            self.url_apikey_param = {}

        self.url_api = "https://services.nvd.nist.gov/rest/json/cves/2.0/?"

    def update(self) -> bool:
        query: dict[str, int | str]
        last_update: datetime | None
        if _last_update_str := self.storage.hget('last_updates', self.name):
            last_update = fromisoformat_wrapper(_last_update_str.decode())
        else:
            last_update = None
        if last_update is None:
            query = {}
        else:
            query = {'lastModStartDate': (last_update - timedelta(hours=10)).isoformat(),
                     'lastModEndDate': (datetime.now() - timedelta(seconds=10)).isoformat()
                     }

        last_update = datetime.now()
        self.logger.debug(f'nvd_query: {query}')

        index = 0
        totalResults = None
        results_per_page = None
        max_results_per_page = 500
        while True:
            query['startIndex'] = index
            query['resultsPerPage'] = max_results_per_page
            r = requests.get(self.url_api, params=query, headers=self.url_apikey_param)
            r.raise_for_status()
            nvd_value = r.json()
            if totalResults is None:
                totalResults = nvd_value["totalResults"]
                self.logger.debug(totalResults)
            results_per_page = len(nvd_value['vulnerabilities'])
            if not results_per_page:
                # No more CVEs
                break
            self.logger.debug(f"index:{index} totalResults:{totalResults}")
            index += results_per_page
            # Store all cves individually
            p = self.storage.pipeline()
            cves: dict[str, float] = {}
            for vuln in nvd_value['vulnerabilities']:
                cve_id = vuln['cve']['id'].lower()
                # do we already have a meta entry for this source?
                if _meta_uuid := self.storage.hget(f'{cve_id}:meta', self.name):
                    meta_uuid = _meta_uuid.decode()
                else:
                    meta_uuid = str(uuid4())
                self.storage.hset(f'{cve_id}:meta', mapping={self.name: meta_uuid})
                self.storage.set(f'{self.name}:{meta_uuid}', orjson.dumps(vuln))
                cves[cve_id] = fromisoformat_wrapper(vuln['cve']['lastModified']).timestamp()
                if not self.storage.exists(cve_id):
                    self.logger.warning(f"{cve_id} is missing.")

                if 'configurations' in vuln['cve']:
                    for configuration in vuln['cve']['configurations']:
                        if 'nodes' not in configuration:
                            continue
                        for node in configuration['nodes']:
                            if 'cpeMatch' not in node:
                                continue
                            for cpematch in node['cpeMatch']:
                                if 'criteria' in cpematch:
                                    _, _, _, vendor, product, _ = cpematch['criteria'].split(':', 5)
                                    vendor = vendor.strip().lower()
                                    product = product.strip().lower()
                                    if not vendor or not product:
                                        # empty, or only spaces
                                        continue
                                    if 'n/a' in vendor or 'n/a' in product:
                                        continue
                                    p.sadd('vendors', vendor)
                                    p.sadd(f'{vendor}:products', product)
                                    p.sadd(f'{vendor}:vulnerabilities', cve_id)
                                    p.sadd(f'{vendor}:{product}:vulnerabilities', cve_id)

            p.zadd(f'index:{self.name}', cves)  # type: ignore
            p.execute()

            if results_per_page < max_results_per_page:
                break
        self.storage.hset('last_updates', mapping={self.name: last_update.isoformat()})
        self.logger.info('Import done.')
        return True
