#!/usr/bin/env python3

from typing import Any
from typing import Dict
from types import ModuleType

import logging
from jsonschema import Draft202012Validator  # type: ignore[import-untyped]

import glob
import importlib.util
import sys
from os.path import dirname, basename, isfile, join

import jsonschema


logger = logging.getLogger(__name__)


def load_module(source: str, module_name: str = "") -> ModuleType | None:
    """
    Reads file source and loads it as a module.

    :param source: file to load
    :param module_name: name of module to register in sys.modules
    :return: loaded module
    """
    module = None
    spec = importlib.util.spec_from_file_location(module_name, source)
    if spec:
        module = importlib.util.module_from_spec(spec)
        if spec.loader:
            sys.modules[module_name] = module
            spec.loader.exec_module(module)
    return module


modules = glob.glob(join(dirname(__file__), "*.py"))

# Loads the validators for the different SA sources found in the local directory
validators: Dict[str, Draft202012Validator] = {
    basename(f)[:-3]: getattr(load_module(f), "validator", None)
    for f in modules
    if isfile(f) and not f.endswith("__init__.py")
}
# Filters keys with None as value
validators = dict(filter(lambda item: item[1] is not None, validators.items()))


def validate_json(data: Any, format: str = "circl") -> None:
    """Checks the format of a JSON object against a JSON schema."""
    try:
        validators[format].validate(data)
        logger.info("Record did pass validation.")
    except jsonschema.exceptions.ValidationError:
        logger.warning("Record did not pass validation.")
        for error in sorted(validators[format].iter_errors(data), key=lambda e: e.path):
            print(error)
        raise
