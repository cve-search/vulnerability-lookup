from typing import Any
from typing import Dict
from typing import Tuple
from datetime import datetime
from datetime import timezone

import logging
from flask_login import current_user  # type: ignore[import-untyped]
from flask_restx import fields  # type: ignore[import-untyped]
from flask_restx import abort
from flask_restx import Namespace
from flask_restx import reqparse
from flask_restx import Resource

from vulnerabilitylookup.default import get_config
from website.web.bootstrap import application
from website.web.bootstrap import db
from website.validators import validate_json
from website.web.api.v1.common import auth_func
from website.web.api.v1.common import metada_params_model
from website.web.api.v1.common import user_params_model
from website.web.api.v1.common import uuid_type
from website.web.api.v1.types import ResultType
from website.models import Bundle
from website.web.permissions import admin_permission

logger = logging.getLogger(__name__)

bundle_ns = Namespace("bundle", description="bundle related operations")

local_instance_uuid = get_config("generic", "local_instance_uuid").lower()

# Argument Parsing
parser = reqparse.RequestParser()
parser.add_argument("uuid", type=uuid_type, help="UUID of the bundle.")
parser.add_argument(
    "author",
    type=str,
    help="Author of the bundle.",
)
parser.add_argument(
    "vuln_id",
    type=str,
    help="Id of a vulnerability referenced by the bundle.",
)

# Response marshalling
bundle_params_model = {
    "uuid": fields.String(description="Bundle id."),
    "vulnerability_lookup_origin": fields.String(
        description="Bundle id.", readonly=True, default=local_instance_uuid
    ),
    "name": fields.String(description="Bundle id."),
    "description": fields.String(description="Description."),
    "creation_timestamp": fields.DateTime(
        description="Updated time of the bundle.", readonly=True
    ),
    "timestamp": fields.DateTime(
        description="Updated time of the bundle.", readonly=True
    ),
    "related_vulnerabilities": fields.List(
        fields.String,
        description="One or more vulnerability references (CVE ID, GHSA-ID, PYSEC ID, etc.) for this bundle.",
    ),
    "meta": fields.Raw(description="Zero or more meta-fields."),
}
bundle = bundle_ns.model("Bundle", bundle_params_model, skip_none=True)
metadata = bundle_ns.model("metadata", metada_params_model)

bundle["author"] = fields.Nested(
    bundle_ns.model("User", user_params_model), readonly=True
)

bundle_list_fields = bundle_ns.model(
    "BundlesList",
    {
        "metadata": fields.Nested(
            metadata, description="Metada related to the result."
        ),
        "data": fields.List(
            fields.Nested(bundle, skip_none=True), description="List of bundles."
        ),
    },
)


@bundle_ns.route("/bundle/<string:bundle_uuid>")
class BundleItem(Resource):  # type: ignore[misc]
    @bundle_ns.doc(description="Get a bundle.")  # type: ignore[misc]
    @bundle_ns.marshal_with(bundle, skip_none=True)  # type: ignore[misc]
    def get(self, bundle_uuid: str) -> Tuple[ResultType, int]:
        result = Bundle.query.filter(Bundle.uuid == bundle_uuid).first()
        if result.meta == []:
            result.meta = None
        return result, 200

    @bundle_ns.doc(description="Delete a bundle.")  # type: ignore[misc]
    @bundle_ns.doc(
        responses={
            204: "Success.",
            403: "Administrator permission required or not the author of the bundle.",
        }
    )  # type: ignore[misc]
    @admin_permission.require(http_exception=403)  # type: ignore[misc]
    @auth_func
    def delete(self, bundle_uuid: str) -> Tuple[dict[Any, Any], int]:
        """Endpoint for deleting a bundle."""
        obj = Bundle.query.filter(Bundle.uuid == bundle_uuid).first()
        if obj:
            if not current_user.is_admin:
                return abort(403, "You cannot delete this bundle.")
            db.session.delete(obj)
            db.session.commit()
        return {}, 204


@bundle_ns.route("/bundle/")
class BundlesList(Resource):  # type: ignore[misc]
    @bundle_ns.doc("list_bundles")  # type: ignore[misc]
    @bundle_ns.expect(parser)  # type: ignore[misc]
    @bundle_ns.marshal_list_with(bundle_list_fields)  # type: ignore[misc]
    def get(self) -> Tuple[ResultType, int]:
        """List all bundles."""
        args = parser.parse_args()
        offset = args.pop("page", 1) - 1
        limit = args.pop("per_page", 10)
        author = args.pop("author", None)
        vuln_id = args.pop("vuln_id", None)

        result: ResultType = {
            "data": [],
            "metadata": {
                "count": 0,
                "offset": offset,
                "limit": limit,
            },
        }

        results = []
        count = 0
        query = Bundle.query
        if author is not None:
            query = query.filter(Bundle.author.has(login=author))
        if vuln_id is not None:
            query = query.filter(Bundle.related_vulnerabilities.contains([vuln_id]))

        query = query.order_by(Bundle.timestamp.desc())
        total = query.count()
        query = query.limit(limit)
        results = query.offset(offset * limit)
        count = total

        result["data"] = results
        result["metadata"]["count"] = count

        return result, 200

    @bundle_ns.doc(description="Create a bundle.")  # type: ignore[misc]
    @bundle_ns.doc(
        responses={
            201: "Success.",
            400: "JSON validation failed or incorrect payload to instantiate a bundle.",
            403: "Administrator permission required.",
        }
    )  # type: ignore[misc]
    @bundle_ns.expect(bundle)  # type: ignore[misc]
    @bundle_ns.marshal_list_with(bundle_list_fields, code=201)  # type: ignore[misc]
    @admin_permission.require(http_exception=403)  # type: ignore[misc]
    @auth_func
    def post(self) -> Tuple[Dict[Any, Any], int]:
        current_time = datetime.now(timezone.utc)
        bundle = bundle_ns.payload
        bundle["vulnerability_lookup_origin"] = local_instance_uuid
        bundle["creation_timestamp"] = current_time.strftime("%Y-%m-%dT%H:%M:%S.%fZ")
        bundle["timestamp"] = current_time.strftime("%Y-%m-%dT%H:%M:%S.%fZ")

        try:
            validate_json(bundle, "circl_bundle")
        except Exception:
            logger.warning("JSON validation failed.")
            abort(400, "JSON validation failed.")

        obj = Bundle.query.filter(Bundle.uuid == bundle["uuid"]).first()
        if obj:
            # edit an existing bundle
            obj.name = bundle["name"]
            obj.description = bundle["description"]
            obj.description_format = bundle.get("description_format", "markdown")
            obj.meta = bundle.get("meta", {})
            obj.timestamp = bundle["timestamp"]
        else:
            # creation of a new bundle
            try:
                new_bundle = Bundle(**bundle, author_id=current_user.id)
            except TypeError:
                abort(400, "JSON validation failed.")
            db.session.add(new_bundle)
        db.session.commit()

        return bundle, 201
