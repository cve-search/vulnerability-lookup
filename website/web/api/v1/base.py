from typing import Any
from typing import Dict
from typing import Tuple
from datetime import datetime

import logging
import orjson
from flask_login import current_user  # type: ignore[import-untyped]
from flask import request
from flask_restx import abort  # type: ignore[import-untyped]
from flask_restx import fields
from flask_restx import Namespace
from flask_restx import reqparse
from flask_restx import Resource
from redis import Redis

from vulnerabilitylookup import __version__
from vulnerabilitylookup.default import get_config
from vulnerabilitylookup.helpers import fromisoformat_wrapper
from website.validators import validate_json
from website.web.api.v1.common import auth_func
from website.web.bootstrap import application
from website.web.bootstrap import vulnerabilitylookup
from website.web.permissions import reporter_permission, admin_permission

logger = logging.getLogger(__name__)

local_instance_name = get_config("generic", "local_instance_name").lower()
local_instance_vulnid_pattern = get_config("generic", "local_instance_vulnid_pattern")

api_ns = Namespace("api", description="core API operations")
default_ns = Namespace("default", description="default operations")

storage = Redis(
    host=get_config("generic", "storage_db_hostname"),
    port=get_config("generic", "storage_db_port"),
)

# Argument Parsing
vulnerability_query_parser = reqparse.RequestParser()
vulnerability_query_parser.add_argument(
    "data",
    type=dict,
    location="json",
    help="The JSON data (CVE version 5 format) of the security advisory.",
)


@api_ns.route("/cve/<string:vulnerability_id>")
@default_ns.route("vulnerability/<string:vulnerability_id>")
class Vulnerability(Resource):  # type: ignore[misc]
    @api_ns.doc(description="Get a vulnerability.")  # type: ignore[misc]
    @default_ns.doc(description="Get a vulnerability.")  # type: ignore[misc]
    def get(self, vulnerability_id: str) -> dict[str, Any] | None:
        with_meta = True if request.args.get("with_meta") else False
        return vulnerabilitylookup.get_vulnerability(
            vulnerability_id, with_meta=with_meta
        )

    @api_ns.doc(description="Delete a vulnerability from the local source.")  # type: ignore[misc]
    @default_ns.doc(description="Delete a vulnerability from the local source.")  # type: ignore[misc]
    @api_ns.doc(
        responses={
            204: "Success.",
            403: "Admin permission required.",
            422: "Not possible to edit a vulnerability from the requested source.",
        }
    )  # type: ignore[misc]
    @admin_permission.require(http_exception=403)  # type: ignore[misc]
    @auth_func
    def delete(self, vulnerability_id: str) -> Tuple[dict[Any, Any], int]:
        """Endpoint for deleting a vulnerability.
        We only accept to delete vulnerabilities from the local source."""
        source = (
            vulnerabilitylookup.get_vulnerability_source(vulnerability_id)
            or local_instance_name
        )
        if source != local_instance_name:
            return abort(
                422,
                "You can only delete a vulnerability fron the source {}.".format(
                    local_instance_name
                ),
            )
        storage.delete(vulnerability_id)
        return {}, 204


@api_ns.route("/cve/")
@default_ns.route("vulnerability/")
class VulnerabilitiesList(Resource):  # type: ignore[misc]
    @api_ns.doc(description="Create a vulnerability with the CVE version 5 format.")  # type: ignore[misc]
    @default_ns.doc(description="Create a vulnerability with the CVE version 5 format.")  # type: ignore[misc]
    @api_ns.doc(
        responses={
            200: "Success.",
            400: "JSON validation failed.",
            403: "Reporter permission required.",
            422: "Not possible to edit a vulnerability from the requested source.",
        }
    )  # type: ignore[misc]
    @default_ns.doc(
        responses={
            200: "Success.",
            400: "JSON validation failed.",
            403: "Reporter permission required.",
            422: "Not possible to edit a vulnerability from the requested source.",
        }
    )  # type: ignore[misc]
    @api_ns.expect(vulnerability_query_parser)  # type: ignore[misc]
    @default_ns.expect(vulnerability_query_parser)  # type: ignore[misc]
    @reporter_permission.require(http_exception=403)  # type: ignore[misc]
    @auth_func
    def post(self) -> Tuple[Dict[Any, Any], int]:
        """Endpoint for creating and editing vulnerabilities in the local source."""
        ids: dict[str, float] = {}

        # Validate the JSON payload
        vuln = default_ns.payload
        if (
            not current_user.is_admin
        ):  # admins can submit non valid JSON for security advisories
            try:
                validate_json(vuln, "circl_vuln")
            except Exception:
                logger.warning("JSON validation failed.")
                abort(400, "JSON validation failed.")

        vuln_id = vuln["cveMetadata"]["vulnId"].lower()
        cve_id = vuln["cveMetadata"].get("cveId", "").lower() or None

        source = (
            vulnerabilitylookup.get_vulnerability_source(vuln_id) or local_instance_name
        )
        if source != local_instance_name:
            logger.warning(
                f"Not possible to edit a vulnerability from the source {source}."
            )
            abort(
                422,
                "You can not edit a vulnerability fron the source {}. You must change the vulnerability ID.".format(
                    source
                ),
            )

        now = datetime.now()

        if "dateUpdated" in vuln["cveMetadata"]:
            updated = fromisoformat_wrapper(vuln["cveMetadata"]["dateUpdated"])
        elif "datePublished" in vuln["cveMetadata"]:
            updated = fromisoformat_wrapper(vuln["cveMetadata"]["datePublished"])
        elif "dateReserved" in vuln["cveMetadata"]:
            updated = fromisoformat_wrapper(vuln["cveMetadata"]["dateReserved"])
        else:
            updated = now
        ids[vuln_id] = updated.timestamp()

        if "datePublished" not in vuln["cveMetadata"]:
            vuln["cveMetadata"]["datePublished"] = now.strftime("%Y-%m-%dT%H:%M:%S.%fZ")
        vuln["cveMetadata"]["dateUpdated"] = now.strftime("%Y-%m-%dT%H:%M:%S.%fZ")

        # Add information about the updater in the cveMetadata field
        if (
            "vulnerabilitylookup_history" not in vuln["cveMetadata"]
            or not vuln["cveMetadata"]["vulnerabilitylookup_history"]
        ):
            vuln["cveMetadata"]["vulnerabilitylookup_history"] = [
                (current_user.email, now.strftime("%Y-%m-%dT%H:%M:%S.%fZ"))
            ]
        else:
            vuln["cveMetadata"]["vulnerabilitylookup_history"].append(
                (current_user.email, now.strftime("%Y-%m-%dT%H:%M:%S.%fZ"))
            )

        new_last_update = now

        # Store the vulnerability in kvrocks
        p = storage.pipeline()
        p.set(vuln_id, orjson.dumps(vuln))

        p.zadd(f"index:{source}", ids)  # type: ignore
        p.zadd("index", ids)  # type: ignore

        if cve_id:
            p.sadd(f"{vuln_id}:link", cve_id)
            p.sadd(f"{cve_id}:link", vuln_id)

        p.hset("last_updates", mapping={source: new_last_update.isoformat()})

        p.execute()

        return vuln, 200


@default_ns.route("redis_up")
@default_ns.doc(description="Check if redis is up and running")
class RedisUp(Resource):  # type: ignore[misc]
    def get(self) -> bool:
        return vulnerabilitylookup.check_redis_up()


@api_ns.route("/dbInfo")
@default_ns.route("info")
@api_ns.doc(
    description="Get more information about the current databases in use and when it was updated"
)
class Info(Resource):  # type: ignore[misc]
    def get(self) -> dict[str, Any]:
        return vulnerabilitylookup.get_info()


@api_ns.route("/configInfo")
@default_ns.route("configInfo")
@api_ns.doc(
    description="Get non-sensitive information about the configuration of the system."
)
class ConfigInfo(Resource):  # type: ignore[misc]
    def get(self) -> dict[str, Any]:
        return {
            "user_accounts": get_config("generic", "user_accounts"),
            "local_instance_uuid": get_config("generic", "local_instance_uuid"),
            "registration": application.config["SELF_REGISTRATION"],
            "moderation": application.config["COMMENTS_MODERATION"],
            "software_version": __version__,
        }


@api_ns.route("/last")
@default_ns.route("last")
@default_ns.route("last/<int:number>")
@default_ns.route("last/<string:source>")
@default_ns.route("last/<string:source>/<int:number>")
@default_ns.doc(description="Get the last CVEs")
class Last(Resource):  # type: ignore[misc]
    def get(
        self, source: str | None = None, number: int | None = 30
    ) -> list[dict[str, Any]]:
        return [entry for v_id, entry in vulnerabilitylookup.get_last(source, number)]


@api_ns.route("/browse")
@default_ns.doc(description="Get the known vendors")
class Vendors(Resource):  # type: ignore[misc]
    def get(self) -> list[str]:
        vendor = request.args.get("vendor", "").lower()
        vendors = list(vulnerabilitylookup.get_vendors())
        if vendor and len(vendor) >= 3:
            vendors = [elem for elem in vendors if vendor in elem]
        return vendors


@api_ns.route("/browse/<string:vendor>")
@api_ns.doc(description="Get the known products for a vendor")
class VendorProducts(Resource):  # type: ignore[misc]
    def get(self, vendor: str) -> list[str]:
        return list(vulnerabilitylookup.get_vendor_products(vendor))


@api_ns.route("/search/<string:vendor>/<string:product>")
@api_ns.doc(description="Get the the vulnerabilities per vendor and a specific product")
class VendorProductVulnerabilities(Resource):  # type: ignore[misc]
    def get(
        self, vendor: str, product: str
    ) -> dict[str, list[tuple[str, dict[str, Any]]]]:
        return vulnerabilitylookup.get_vendor_product_vulnerabilities(vendor, product)
