from typing import Any
from typing import Dict
from typing import Tuple

import logging
from sqlalchemy import exc
from flask_login import current_user  # type: ignore[import-untyped]
from flask_restx import fields  # type: ignore[import-untyped]
from flask_restx import abort
from flask_restx import Namespace
from flask_restx import reqparse
from flask_restx import Resource
from sqlalchemy import delete

from website.models import Bundle
from website.models import Comment
from website.models import User
from website.notifications import notifications
from website.web.bootstrap import db
from website.web.api.v1.common import auth_func, metada_params_model
from website.web.api.v1.types import ResultType
from website.web.permissions import admin_permission

logger = logging.getLogger(__name__)

user_ns = Namespace("user", description="user related operations")


# Argument Parsing
parser = reqparse.RequestParser()
parser.add_argument("login", type=str, location="json", help="Login.")
parser.add_argument(
    "name", type=str, location="json", help="Display name (firstname, lastname)."
)
parser.add_argument("organisation", type=str, location="json", help="Organisation.")
parser.add_argument("email", type=str, location="json", help="Email.")


# Response marshalling
user_params_model = {
    "id": fields.Integer(description="User id."),
    "login": fields.String(description="User login."),
    "name": fields.String(description="User name."),
    "organisation": fields.String(description="User organisation."),
    "email": fields.String(description="User email."),
    "apikey": fields.String(description="User API key.", readonly=True),
    "is_admin": fields.Boolean(
        description="Boolean specifying whether the user is administrator."
    ),
    "is_reporter": fields.Boolean(
        description="Boolean specifying whether the user is administrator."
    ),
    "is_commenter": fields.Boolean(
        description="Boolean specifying whether the user is administrator."
    ),
    "created_at": fields.DateTime(
        description="Creation time of the user.", readonly=True
    ),
    "last_seen": fields.DateTime(
        description="Last seen time of the user.", readonly=True
    ),
}
user_model = user_ns.model("UserFull", user_params_model)
metadata = user_ns.model("metadata", metada_params_model)

user_list_fields = user_ns.model(
    "UsersList",
    {
        "metadata": fields.Nested(
            metadata, description="Metada related to the result."
        ),
        "data": fields.List(
            fields.Nested(user_model, skip_none=True), description="List of users."
        ),
    },
)


@user_ns.route("/user/me")
class UserSelf(Resource):  # type: ignore[misc]
    @user_ns.doc(description="Get information about the currently authenticated user.")  # type: ignore[misc]
    @user_ns.doc(
        responses={
            200: "Success.",
            404: "User not found.",
        }
    )  # type: ignore[misc]
    @user_ns.marshal_with(user_model, skip_none=True)  # type: ignore[misc]
    @auth_func
    def get(self) -> Tuple[dict[Any, Any], int]:
        "Get information about the currently authenticated user."
        me = User.query.filter(
            User.id == current_user.id,
            User.is_active == True,
            User.is_confirmed == True,
        ).first()
        if not me:
            return {"message": "User not found."}, 404
        return me, 200


@user_ns.route("/user/api_key")
class UserNewAPIKey(Resource):  # type: ignore[misc]
    @user_ns.doc(description="Regenerating the API key of the authenticated user with the current API key.")  # type: ignore[misc]
    @user_ns.doc(
        responses={
            200: "Success.",
            403: "Wrong API key submitted.",
            404: "User not found.",
        }
    )  # type: ignore[misc]
    @user_ns.expect(
        user_ns.model("API Key", {"apikey": fields.String(description="The current API key of the user.")}, location="json")
    )  # type: ignore[misc]
    @user_ns.marshal_with(user_model, skip_none=True)  # type: ignore[misc]
    @auth_func
    def post(self) -> Tuple[dict[Any, Any], int]:
        "Regenerating the API key of the authenticated user with the current API key."
        user_obj = User.query.filter(
            User.id == current_user.id,
            User.is_active == True,
            User.is_confirmed == True,
        ).first()

        if not user_obj:
            return {"message": "User not found."}, 404

        data = user_ns.payload

        if user_obj.apikey != data.get("apikey", ""):
            return {"message": "Wrong API key submitted."}, 403

        user_obj.generate_apikey()
        db.session.commit()

        return user_obj, 200


@user_ns.route("/user/<string:user_id>")
class UserItem(Resource):  # type: ignore[misc]
    @user_ns.doc(description="Delete a user.")  # type: ignore[misc]
    @user_ns.doc(
        responses={
            204: "Success.",
            403: "Administrator permission required or not the current user.",
            404: "User not found.",
        }
    )  # type: ignore[misc]
    @auth_func
    def delete(self, user_id: str) -> Tuple[dict[Any, Any], int]:
        """Endpoint for deleting a user."""
        user = User.query.filter(User.id == user_id).first()
        if not user:
            return {"message": "User not found."}, 404

        if not current_user.is_admin and current_user.id != user.id:
            return abort(403, "You cannot delete this user.")

        if current_user.is_admin:
            # Delete contributed comments
            statement = delete(Comment).where(Comment.author_id == user_id)
            db.session.execute(statement)
            # Delete contributed bundles
            statement = delete(Bundle).where(Bundle.author_id == user_id)
            db.session.execute(statement)
            # Delete the user
            db.session.delete(user)
            db.session.commit()
        else:
            user.is_active = False
            db.session.commit()

        return {}, 204


@user_ns.route("/user/")
class UsersList(Resource):  # type: ignore[misc]
    @user_ns.doc("list_users")  # type: ignore[misc]
    @user_ns.doc(
        responses={
            200: "Success.",
            403: "Admin permission required.",
        }
    )  # type: ignore[misc]
    @user_ns.marshal_list_with(user_list_fields)  # type: ignore[misc]
    @auth_func
    @admin_permission.require(http_exception=403)  # type: ignore[misc]
    def get(self) -> Tuple[ResultType, int]:
        """List all users. Only available to administrators."""
        args = parser.parse_args()
        offset = args.pop("page", 1) - 1
        limit = args.pop("per_page", 10)

        result: ResultType = {
            "data": [],
            "metadata": {
                "count": 0,
                "offset": offset,
                "limit": limit,
            },
        }

        results = []
        count = 0
        query = User.query
        total = query.count()
        query = query.limit(limit)
        results = query.offset(offset * limit)
        count = total

        result["data"] = results
        result["metadata"]["count"] = count

        return result, 200

    @user_ns.doc(description="Create a non-admin user.")  # type: ignore[misc]
    @user_ns.doc(
        responses={
            201: "Success.",
        }
    )  # type: ignore[misc]
    @user_ns.expect(parser)  # type: ignore[misc]
    @user_ns.marshal_with(user_model)  # type: ignore[misc]
    def post(self) -> Tuple[Dict[Any, Any], int]:
        """Create a non-admin user.
        The user will be active but must have to confirm the account with the email sent by the instance.
        """
        try:
            new_user = User(
                **user_ns.payload,
                pwdhash="",
                is_admin=False,
                is_active=True,
                is_confirmed=False,
            )
            db.session.add(new_user)
            db.session.commit()
        except AssertionError as e:
            return abort(400, f"{e}")
        except exc.IntegrityError:
            db.session.rollback()
            return abort(400, "Impossible to create the user.")

        # Send the confirmation email
        try:
            notifications.confirm_account(new_user)
        except Exception as error:
            logger.warning(f"Problem while sending activation email: {error}")

        return new_user, 201
