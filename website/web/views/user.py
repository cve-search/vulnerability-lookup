#!/usr/bin/env python3

from datetime import timezone
from flask import abort
from flask import Blueprint
from flask import flash
from flask import make_response
from flask import session
from flask import Response
from flask import redirect
from flask import render_template
from flask import request
from flask import url_for
from flask_login import current_user  # type: ignore[import-untyped]
from flask_login import login_required
from flask_paginate import get_page_args  # type: ignore[import-untyped]
from flask_paginate import get_parameter
from flask_paginate import Pagination
from feedgen.feed import FeedGenerator  # type: ignore[import-untyped]
from sqlalchemy import func
from werkzeug import Response as WerkzeugResponse
from werkzeug.security import generate_password_hash

from vulnerabilitylookup.default import get_config
from website.notifications import notifications
from website.web.bootstrap import application
from website.web.bootstrap import db
from website.web.bootstrap import vulnerabilitylookup
from website.lib.user_utils import confirm_token
from website.models import Bundle
from website.models import Comment
from website.models import User
from website.web.forms import ProfileForm
from website.web.forms import AccountConfirmationForm
from website.web.forms import AccountRecoveryForm
from website.web.permissions import reporter_permission

user_bp = Blueprint("user_bp", __name__, url_prefix="/user", template_folder="user")
users_bp = Blueprint("users_bp", __name__, url_prefix="/users", template_folder="user")


@users_bp.route("/", methods=["GET"])
def list_users() -> str:
    """Returns a page with a list of users (directory)."""
    users_sorted_by_contributions = (
        db.session.query(User.login, func.count(User.id))
        .filter(User.is_active == True, User.is_confirmed)
        .join(User.comments)
        .group_by(User.login)
        .all()
    )
    users_sorted_by_contributions.sort(key=lambda tup: tup[1], reverse=True)
    contributors_login = [user[0] for user in users_sorted_by_contributions]
    non_contributors = (
        User.query.filter(User.is_active == True, User.is_confirmed)
        .order_by(User.last_seen.desc())
        .filter(~User.login.in_(contributors_login))
    )

    users = []
    for user in contributors_login:
        users.append(User.query.filter(User.login == user).first())
    users.extend(non_contributors.all())

    page, per_page, offset = get_page_args(
        page_parameter="page", per_page_parameter="per_page"
    )
    page_name = get_parameter()
    per_page_name = get_parameter(default="per_page")
    pagination = Pagination(
        total=len(users),
        record_name="users",
        css_framework="bootstrap5",
        **{page_name: page, per_page_name: per_page},
    )
    users = users[offset : offset + per_page]
    return render_template("user/users.html", users=users, pagination=pagination)


@user_bp.route("/<string:login>", methods=["GET"])
def profile(login: str = "") -> str:
    """Returns a page with some information about the user given in parameter."""
    user = User.query.filter(User.login == login).first()
    if user is None:
        abort(404)
    return render_template("user/user.html", user=user)


@user_bp.route("/profile", methods=["GET"])
@login_required  # type: ignore[misc]
def form() -> str:
    """Returns the form to edit the current user."""
    user = User.query.filter(User.id == current_user.id).first()
    form = ProfileForm(obj=user)
    form.populate_obj(current_user)
    action = "Edit user"
    head_titles = [action]
    head_titles.append(user.login)
    return render_template(
        "user/edit_user.html",
        action=action,
        head_titles=head_titles,
        form=form,
        user=user,
    )


@user_bp.route("/profile", methods=["POST"])
@login_required  # type: ignore[misc]
def process_form() -> str | WerkzeugResponse:
    """Process the form for the user edition."""
    form = ProfileForm()
    user = User.query.filter(User.id == current_user.id).first()

    if not form.validate():
        return render_template("user/edit_user.html", form=form, user=user)

    form.populate_obj(user)
    if form.password.data:
        user.pwdhash = generate_password_hash(form.password.data)
    db.session.commit()
    flash(
        f"User {form.login.data} successfully updated.",
        "success",
    )
    return redirect(url_for("user_bp.form"))


@user_bp.route("/generate_apikey", methods=["GET"])
@login_required  # type: ignore[misc]
def generate_apikey() -> WerkzeugResponse:
    """Generate an API key for a user."""
    user = User.query.filter(User.id == current_user.id).first()
    if user is None:
        abort(404)
    user.generate_apikey()
    db.session.commit()
    flash("New API key generated.", "success")
    return redirect(url_for("user_bp.form"))


@user_bp.route("/delete_account", methods=["GET"])
@login_required  # type: ignore[misc]
def delete_account() -> WerkzeugResponse:
    """Delete the account of a user."""
    user = User.query.filter(User.id == current_user.id).first()
    if user is None:
        abort(404)
    db.session.delete(user)
    db.session.commit()
    flash("Account deleted.", "success")
    return redirect(url_for("index"))


@user_bp.route("/confirm_account/<string:token>", methods=["GET", "POST"])
def confirm_account(token: str = "") -> str | WerkzeugResponse:
    """
    Confirm the account of a user with the token that the user has received
    previously by email.
    """
    # Check the token
    user, login = None, None
    if token != "":
        login = confirm_token(token)
    if login:
        user = User.query.filter(User.login == login).first()
    if user is None:
        flash("Impossible to activate this account.", "danger")
        return redirect(url_for("user_bp.login"))

    # Management of the Web form
    form = AccountConfirmationForm()

    if request.method == "GET":
        # Asks the user to provide a new password, in the case the token is
        # valid
        if user is not None:
            return render_template("user/account_recovery_set_password.html", form=form)
        else:
            flash("Impossible to activate this account.", "danger")
    else:
        # Update the password of the user (if the token is valid and if the
        # two passwards are equal)
        if form.password1.data == form.password2.data:
            user.pwdhash = generate_password_hash(form.password1.data)
            user.is_confirmed = True
            db.session.add(user)
            db.session.commit()
            flash("Your password has been updated.", "success")
        else:
            flash("Password must be the same.", "danger")
            return render_template("user/account_recovery_set_password.html", form=form)

        if not user.is_two_factor_authentication_enabled:
            session["username"] = user.login
            return redirect(url_for("user_bp.setup_two_factor_auth"))

    return redirect(url_for("user_bp.login"))


@user_bp.route("/account_recovery", methods=["GET", "POST"])
def account_recovery() -> str | WerkzeugResponse:
    """Returns a form for the account recovery.
    The user will have to provide the login of the account to recover. It can
    not be done via email address since an email address is not unique.
    """
    form = AccountRecoveryForm()
    if request.method == "GET":
        return render_template("user/account_recovery.html", form=form)
    else:
        user = User.query.filter(User.login == form.login.data).first()
        if user is None:
            flash(
                "This user does not exist.",
                "danger",
            )
            return redirect(url_for("home_bp.search"))

        # Send the recovery email with the temporary token
        try:
            notifications.account_recovery(user)
        except Exception as error:
            flash(
                f"Problem while sending activation email: {error}",
                "danger",
            )
            return redirect(url_for("home_bp.search"))

        flash("An email with a recovery link has been sent to you.", "success")

    return redirect(url_for("home_bp.search"))


@user_bp.route("/submit", methods=["GET"])
@user_bp.route("/edit/<string:vulnerability_id>", methods=["GET"])
@login_required  # type: ignore[misc]
@reporter_permission.require(http_exception=403)  # type: ignore[misc]
def vulnogram(vulnerability_id: str = "") -> str | WerkzeugResponse:
    """Returns a form using vulnogram in order to edit or create a new vulnerability (CVE list v5)."""
    vulnerability = vulnerabilitylookup.get_vulnerability(
        vulnerability_id, with_meta=True
    )
    if vulnerability_id and None is vulnerability:
        flash(f"Nothing found in the database for {vulnerability_id}.", "warning")
        return redirect(url_for("home_bp.search"))

    local_instance_name = get_config("generic", "local_instance_name").lower()
    local_instance_vulnid_pattern = get_config(
        "generic", "local_instance_vulnid_pattern"
    )
    local_instance_vulnid_example = get_config(
        "generic", "local_instance_vulnid_example"
    )
    source = vulnerabilitylookup.get_vulnerability_source(vulnerability_id)
    return render_template(
        "vulnogram/index.html",
        vulnerability_id=vulnerability_id,
        source=source,
        local_instance_name=local_instance_name,
        local_instance_vulnid_pattern=local_instance_vulnid_pattern,
        local_instance_vulnid_example=local_instance_vulnid_example,
    )


@user_bp.route(
    "/<string:login>.<string:format>", defaults={"per_page": 10}, methods=["GET"]
)
def feed_activity(
    login: str = "", per_page: int = 10, format: str = "atom"
) -> Response:
    """RSS/ATOM feed for the recent activity of a user. In this context activity is
    the creation of a comment or a bundle."""
    public_domain = get_config("generic", "public_domain")
    _, per_page, offset = get_page_args(
        page_parameter="page", per_page_parameter="per_page"
    )
    feed_max_per_page = application.config.get("FEED_MAX_PER_PAGE", 50)
    if per_page > feed_max_per_page:
        per_page = feed_max_per_page

    fg = FeedGenerator()
    fg.id(f"https://{public_domain}/comment/feed")
    fg.title(f"Most recent activity.")
    fg.author(
        {
            "name": "Vulnerability Lookup",
            "email": application.config.get("ADMIN_EMAIL", ""),
        }
    )
    fg.link(href=f"https://{public_domain}", rel="alternate")
    fg.subtitle(f"Contains the recent activity for {{ login }}.")
    fg.language("en")

    query = Comment.query.filter(Comment.is_published == True)
    query = query.filter(Comment.author.has(login=login))
    query = query.order_by(Comment.timestamp.desc())
    comments = query.offset(offset).limit(per_page)
    for comment in comments:
        fe = fg.add_entry()
        fe.id(f"https://{public_domain}/comment/{comment.uuid}")
        fe.title(comment.title)
        fe.link(href=f"https://{public_domain}/comment/{comment.uuid}")
        fe.content(comment.description)
        fe.description(comment.description)
        fe.published(comment.timestamp.replace(tzinfo=timezone.utc))

    query = Bundle.query
    query = query.filter(Bundle.author.has(login=login))
    query = query.order_by(Bundle.timestamp.desc())
    bundles = query.offset(offset).limit(per_page)
    for bundle in bundles:
        fe = fg.add_entry()
        fe.id(f"https://{public_domain}/bundle/{bundle.uuid}")
        fe.title(bundle.name)
        fe.link(href=f"https://{public_domain}/bundle/{bundle.uuid}")
        fe.content(bundle.description)
        fe.description(bundle.description)
        fe.published(bundle.timestamp.replace(tzinfo=timezone.utc))

    if format == "atom":
        feed = fg.atom_str(pretty=True)
    else:
        feed = make_response(fg.rss_str(pretty=True))
        feed.mimetype = "application/rss+xml"
        feed.headers["Content-Type"] = "application/rss+xml"
    return feed
