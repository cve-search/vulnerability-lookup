#!/usr/bin/env python3

import sqlalchemy
from datetime import datetime
from flask import abort
from flask import current_app
from flask import flash
from flask import render_template
from flask import redirect
from flask import request
from flask import session
from flask import url_for
from flask_login import current_user  # type: ignore[import-untyped]
from flask_login import LoginManager
from flask_login import login_required
from flask_login import logout_user
from flask_principal import AnonymousIdentity
from flask_principal import identity_changed
from flask_principal import identity_loaded
from flask_principal import Principal  # type: ignore[import-untyped]
from flask_principal import session_identity_loader
from flask_principal import UserNeed
from werkzeug import Response as WerkzeugResponse

from website.web.permissions import admin_role
from website.web.permissions import commenter_role
from website.web.permissions import login_user_bundle
from website.web.permissions import reporter_role

from website.lib.user_utils import get_b64encoded_qr_image
from website.models import User
from website.notifications import notifications
from website.web.bootstrap import application
from website.web.bootstrap import db
from website.web.forms import LoginForm
from website.web.forms import SignupForm
from website.web.forms import TwoFactorForm
from website.web.views.user import user_bp

Principal(current_app)
# Create a permission with a single Need, in this case a RoleNeed.

login_manager = LoginManager()
login_manager.init_app(current_app)
login_manager.login_view = "user_bp.login"
login_manager.login_message = "Please log in to access this page."
login_manager.login_message_category = "info"


@identity_loaded.connect_via(current_app._get_current_object())  # type: ignore
def on_identity_loaded(sender, identity) -> None:
    # Set the identity user object
    identity.user = current_user

    # Add the UserNeed to the identity
    if current_user.is_authenticated:
        identity.provides.add(UserNeed(current_user.id))
        if current_user.is_admin:
            identity.provides.add(admin_role)
        if current_user.is_commenter:
            identity.provides.add(commenter_role)
        if current_user.is_reporter:
            identity.provides.add(reporter_role)
            identity.provides.add(commenter_role)


@login_manager.user_loader
def load_user(user_id: int) -> bool:
    return User.query.filter(User.id == user_id, User.is_active == True, User.is_confirmed == True).first()  # noqa


@current_app.before_request
def before_request() -> None:
    if current_user.is_authenticated:
        current_user.last_seen = datetime.now()
        db.session.commit()


@user_bp.route("/login", methods=["GET", "POST"])
def login() -> str |  WerkzeugResponse:
    if current_user.is_authenticated:
        if current_user.is_two_factor_authentication_enabled:
            flash("You are already logged in.", "info")
            return redirect(url_for("user_bp.form"))
        else:
            flash("You have not enabled 2-Factor Authentication. Please enable it.", "info")
            return redirect(url_for("user_bp.setup_two_factor_auth"))

    form = LoginForm()
    if request.method == "POST" and form.validate():
        session['username'] = form.login.data
        user = User.query.filter(User.login == session['username'], User.is_active == True, User.is_confirmed == True).first()
        if not user.is_two_factor_authentication_enabled:
            flash("You have not enabled 2-Factor Authentication. Please enable first to login.", "info")
            return redirect(url_for("user_bp.setup_two_factor_auth"))
        return redirect(url_for("user_bp.verify_two_factor_auth"))

    return render_template("user/login.html", form=form)


@user_bp.route("/logout")
@login_required
def logout() -> WerkzeugResponse:
    # Remove the user information from the session
    logout_user()

    session.pop("username", None)

    # Remove session keys set by Flask-Principal
    for key in ("identity.name", "identity.auth_type"):
        session.pop(key, None)

    # Tell Flask-Principal the user is anonymous
    identity_changed.send(current_app, identity=AnonymousIdentity())
    session_identity_loader()

    return redirect(url_for("user_bp.login"))


@user_bp.route("/signup", methods=["GET", "POST"])
def signup() -> str | WerkzeugResponse:
    if not application.config["SELF_REGISTRATION"]:
        flash("Self-registration is disabled.", "warning")
        return redirect(url_for("home_bp.search"))
    if current_user.is_authenticated:
        return redirect(url_for("user_bp.form"))

    form = SignupForm()
    # if form.validate_on_submit():
    if request.method == "POST" and form.validate():
        try:
            new_user = User(
                login=form.login.data,
                email=form.email.data,
                pwdhash="",
                is_active=True,
                is_confirmed=False,
                is_admin=False,
            )
            db.session.add(new_user)
            db.session.commit()
        except sqlalchemy.exc.IntegrityError:
            db.session.rollback()

        # Send the confirmation email
        try:
            notifications.confirm_account(new_user)
        except Exception as error:
            flash(f"Problem while sending activation email: {error}",
                "danger",
            )

        flash(
            "Your account has been created. Check your mail to confirm it.",
            "success",
        )

        return redirect(url_for("home_bp.search"))

    return render_template("user/signup.html", form=form)


@user_bp.route("/setup-2fa", methods=["GET"])
def setup_two_factor_auth() -> str:
    """Setup Two-Factor authentication for the username in session.
    A QRCode is generated and returned in the HTML page."""
    assert None is not session.get("username", None), abort(403)
    user = User.query.filter(User.login == session['username'], User.is_active == True, User.is_confirmed == True).first()
    if user is None:
        session.pop("username", None)
        abort(403)
    secret = user.secret_token
    uri = user.get_authentication_setup_uri()
    base64_qr_image = get_b64encoded_qr_image(uri)
    # make sure the browser does not cache the QRCode
    return render_template("user/setup-2fa.html", secret=secret, qr_image=base64_qr_image), 200, {
        'Cache-Control': 'no-cache, no-store, must-revalidate',
        'Pragma': 'no-cache',
        'Expires': '0'}


@user_bp.route("/verify-2fa", methods=["GET", "POST"])
def verify_two_factor_auth() -> str | WerkzeugResponse:
    """Verify the token generated by the authentication software of the user."""
    assert None is not session.get("username", None), abort(403)
    user = User.query.filter(User.login == session['username'], User.is_active == True, User.is_confirmed == True).first()
    if user is None:
        session.pop("username", None)
        abort(403)
    form = TwoFactorForm(request.form)
    if form.validate_on_submit():
        if user.is_otp_valid(form.otp.data):
            if user.is_two_factor_authentication_enabled:
                # Verification
                flash("2FA verification successful. You are logged in!", "success")
                session.pop("username", None)
                login_user_bundle(user)
                return redirect(url_for("user_bp.form"))
            else:
                # Setup of Two-Factor Authentication
                try:
                    user.is_two_factor_authentication_enabled = True
                    db.session.commit()
                    session.pop("username", None)
                    flash("2FA setup successful. You are logged in!", "success")
                    login_user_bundle(user)
                    return redirect(url_for("user_bp.form"))
                except Exception:
                    db.session.rollback()
                    flash("2FA setup failed. Please try again.", "danger")
                    return redirect(url_for("user_bp.verify_two_factor_auth"))
        else:
            flash("Invalid OTP. Please try again.", "danger")
            return redirect(url_for("user_bp.verify_two_factor_auth"))
    else:
        if not user.is_two_factor_authentication_enabled:
            flash("You have not enabled 2-Factor Authentication. Please enable it first.", "info")
        return render_template("user/verify-2fa.html", form=form)
